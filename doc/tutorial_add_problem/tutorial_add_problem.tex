\documentclass[11pt]{article}
\usepackage[left=2.5cm,right=2.5cm,top=3cm,bottom=3cm,a4paper]{geometry}
\usepackage{graphicx}
\usepackage{dhucs}
\usepackage{mathrsfs,amsmath,amssymb,amscd,mathtools,amsthm}
\usepackage{array}
\usepackage{algorithm2e}
\usepackage{algpseudocode}
\usepackage{hyperref}
\usepackage{indentfirst}
\usepackage{subfig}
\usepackage{adjustbox}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{color}
\usepackage{setspace}
\usepackage{rotating}
\usepackage{filecontents}
\usepackage{authblk}
\usepackage{soul}
\usepackage{float}
\usepackage{caption}
\usepackage{xspace}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage[flushleft]{threeparttable}
\usepackage{forest}
\usepackage[graphicx]{realboxes}
\onehalfspacing

%\graphicspath{{./figures/}}

% set shortcuts
%% Math notations
\DeclareMathOperator*{\PP}{\mathbb{P}}
\DeclareMathOperator*{\EE}{\mathbb{E}}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

%% Package, Library, abbreviate terms
\newcommand{\siplibtwo}{\textsf{SIPLIB 2.0}}
\newcommand{\siplib}{\textsf{SIPLIB}}
\newcommand{\miplib}{\textsf{MIPLIB 2010}}
\newcommand{\smps}{\textsf{SMPS}}
\newcommand{\mps}{\textsf{MPS}}
\newcommand{\mpsx}{\textsf{MPSX}}
\newcommand{\jump}{\textsf{JuMP}}
\newcommand{\structjump}{\textsf{StructJuMP}}

% Problems
\newcommand{\dcap}{\textsf{DCAP}}
\newcommand{\dclp}{\textsf{DCLP}}
\newcommand{\mptsps}{\textsf{MPTSPs}}
\newcommand{\sizes}{\textsf{SIZES}}
\newcommand{\smkp}{\textsf{SMKP}}
\newcommand{\sslp}{\textsf{SSLP}}
\newcommand{\suc}{\textsf{SUC}}

% Solvers
\newcommand{\dsp}{\textsf{DSP}}
\newcommand{\pysp}{\textsf{PySP}}
\newcommand{\pyomo}{\textsf{Pyomo}}
\newcommand{\cplex}{\textsf{CPLEX}}

%% Programming languages
\newcommand{\julia}{\texttt{Julia}}
\newcommand{\python}{\texttt{Python}}
\newcommand{\clang}{\texttt{C}}
\newcommand{\cpp}{\texttt{C++}}
\newcommand{\matlab}{\texttt{MATLAB}}

%% Siplib.jl related terms
\newcommand{\jumpmodel}{\texttt{JuMP.Model}}
\newcommand{\siplibjl}{\texttt{Siplib.jl}}

% for folder tree
% for Siplib.jl tree
\definecolor{folderbg}{RGB}{124,166,198}
\definecolor{folderborder}{RGB}{110,144,169}
\def\Size{4pt}
\tikzset{
	folder/.pic={
		\filldraw[draw=folderborder,top color=folderbg!50,bottom color=folderbg]
		(-1.05*\Size,0.2\Size+5pt) rectangle ++(.75*\Size,-0.2\Size-5pt);  
		\filldraw[draw=folderborder,top color=folderbg!50,bottom color=folderbg]
		(-1.15*\Size,-\Size) rectangle (1.15*\Size,\Size);
	}
}


% for Julia script
\lstdefinelanguage{julia}
{
	sensitive=true,	
	basicstyle=\ttfamily\scriptsize,
	columns=fullflexible, % make sure to use fixed-width font, CM typewriter is NOT fixed width
	numbers=left, 
	numberstyle=\small\ttfamily\color{Gray},
	stepnumber=0,              
	numbersep=10pt, 
	numberfirstline=true, 
	numberblanklines=true, 
	tabsize=4,
	lineskip=-1.5pt,
	extendedchars=true,
	breaklines=true,        
	keywordstyle=\color{Blue}\bfseries,
	identifierstyle=, % using emph or index keywords
	commentstyle=\sffamily\color{OliveGreen},
	stringstyle=\color{Maroon},
	showstringspaces=false,
	showtabs=false,
	upquote=false,
	keywordsprefix=\@,
	keywords={exit,whos,edit,load,is,isa,isequal,typeof,tuple,ntuple,uid,hash,finalizer,convert,promote,
		subtype,typemin,typemax,realmin,realmax,sizeof,eps,promote_type,method_exists,applicable,
		invoke,dlopen,dlsym,system,error,throw,assert,new,Inf,Nan,pi,im,begin,while,for,in,return,
		break,continue,macro,quote,let,if,elseif,else,try,catch,end,bitstype,ccall,do,using,module,
		import,export,importall,baremodule,immutable,local,global,const,Bool,Int,Int8,Int16,Int32,
		Int64,Uint,Uint8,Uint16,Uint32,Uint64,Float32,Float64,Complex64,Complex128,String,Symbol,Any,Nothing,None,
		function,type,typealias,abstract,struct, mutable},
	comment=[l]{\#},
	%morecomment=[s]{#=}{=#},
	morestring=[d]\',
	morestring=[b]\",
}

\begin{document}
\nocite{*}
\title{Adding \dcap\ to \siplibjl}
\author{Yongkyu Cho}
\affil{POSTECH\\ E-mail: jyg1124@postech.ac.kr}
\maketitle
\section{Assumptions}
\begin{itemize}
	\item You have $\julia\ge 0.6.2$. You know some basic \julia\ syntax.
	\item You know how to model with \jump.
	\item You have a two-stage stochastic programming problem (e.g., \dcap\ \ref{DCAP}) that you want to add to \siplibjl. You know everything about the problem, e.g., formulation, probability distributions.
	\item Your \siplibjl\ package is located in \texttt{/dir/Siplib}.
\end{itemize}

\section{Tutorial}
Follow the steps to add a new problem. Be very careful whenever you make a new component that is named based on the problem name (e.g., folder, script, function, composite-type). You must be consistent with the predefined manner. Otherwise, it will cause error. 
\subsection{Modify and save the file: \texttt{/dir/Siplib/src/problem\_info.csv}}
\texttt{problem\_info.csv} file contains parameter information for each problem. Open the file and add the following comma-delimited line at the bottom:
\begin{quote}\noindent\centering \texttt{DCAP,4,"[R, N, T, S], All integers."}\end{quote}
\begin{itemize}
	\item \texttt{DCAP}: Name of the problem.
	\item \texttt{4}: Number of parameters for the problem.
	\item \texttt{"[R, N, T, S], All integers."}: You can put any note on the parameters. If you do not feel like to put anything, just let it \texttt{""}.
\end{itemize}
Later, \smps\ files will be generated using the function with at least two input arguments, e.g.,: 
\begin{lstlisting}[frame=single,language=julia]
julia> generateSMPS(:DCAP,[3,3,3,10])
\end{lstlisting}

\subsection{Create a new folder \texttt{DCAP} under: \texttt{/dir/Siplib/src/problem/}}
So, you must have a directory: \texttt{/dir/Siplib/src/problem/DCAP/}
\subsection{Create, Write, and Place \texttt{DCAP\_data.jl} file into: \texttt{/dir/Siplib/src/problem/DCAP/}}
Make a new julia script file using the problem name. For \dcap, it must be \texttt{DCAP\_data.jl}. This file must contain two definitions with predefined naming rule and set of input arguments. For \texttt{DCAP\_data.jl},
\begin{itemize}
	\item Definition of a composite-type \texttt{DCAPData} that will contain instance data.
	\item Definition of a function
	\begin{quote}\centering\noindent\texttt{DCAPData(nR::Int, nN::Int, nT::Int, nS::Int, seed::Int)::DCAPData}\end{quote}
	that will generate data and return it with a \texttt{DCAPData}-type object. The argument \texttt{seed} must be placed at the end.
\end{itemize}
For example, \texttt{DCAP\_data.jl} must be written by (please see the comment for each line):
\begin{lstlisting}[frame=single,language=julia]
# definition of data container
mutable struct DCAPData	# `mutable struct' is Julia's composite type
	# Sets
	R   # set of resources (i ∈ R)
	N   # set of tasks (j ∈ N)
	T   # set of time periods (t ∈ T)
	S   # set of scenarios (s ∈ S)
	
	# Parameters
	a   # a[i,t]: variable cost for expanding capacity of resource i at time t
	b   # b[i,t]: fixed cost for expanding capacity of resource i at time t
	c   # c[i,j,t,s]: cost of processing task j using resource i in period t under scenario s
	c0  # c0[j,t,s]: penalty cost of failing to assign a resource to task j under scenario s
	d   # d[j,t,s]: processing requirement for task j in period t under scenario s
	
	Pr  # Pr[s]: probability of occurence of scenario s
	
	DCAPData() = new()	# constructor
end

# data generating function
## nR: number of resources, nN: number of tasks, nT: number of times, nS: number of scenarios, seed: random seed
function DCAPData(nR::Int, nN::Int, nT::Int, nS::Int, seed::Int)::DCAPData
	
	srand(seed)	# set a random seed
	data = DCAPData()	# construct empty container
	
	# store Sets
	data.R = 1:nR	# set range for R
	data.N = 1:nN	# set range for N
	data.T = 1:nT	# set range for T
	data.S = 1:nS	# set range for S
	
	# store Parameters
	data.a = rand(nR, nT) * 5 + 5	# generate and store random data
	data.b = rand(nR, nT) * 40 + 10	# generate and store random data
	data.c = rand(nR, nN, nT, nS) * 5 + 5	# generate and store random data
	data.c0 = rand(nN, nT, nS) * 500 + 500	# generate and store random data
	data.d = rand(nN, nT, nS) + 0.5	# generate and store random data

	data.Pr = ones(nS)/nS	# store probability of occurence of scenarios
	
	return data
end

\end{lstlisting}
\subsection{Create, Write, and Place \texttt{DCAP\_model.jl} file into: \texttt{/dir/Siplib/src/problem/DCAP/}}
Make a new julia script file using the problem name again. For \dcap, it must be \texttt{DCAP\_model.jl}. This file must include the file \texttt{DCAP\_data.jl} we created above. This file must also contain a definition of a function with the name \texttt{DCAP}.
\begin{itemize}
	\item Inclusion of the \julia\ script: \texttt{DCAP\_data.jl}.
	\item Definition of a function
	\begin{quote}\centering\noindent\texttt{DCAP(nR::Int, nN::Int, nT::Int, nS::Int, seed::Int=1)::JuMP.Model
	}\end{quote}
	that will return a \jumpmodel-type object. The set of arguments and its order are the same as \texttt{DCAPData()} except for the \texttt{seed} that must have a default value 1, i.e., \texttt{seed::Int=1}.
\end{itemize}
For example, \texttt{DCAP\_data.jl} must be written as the following script. Please see the comment for each line to learn how to model a stochastic program with StructJuMP syntax.
\begin{lstlisting}[frame=single,language=julia]
include("./DCAP_data.jl")	# Do not forget to include DCAP_data.jl file we defined above

# JuMP.Model constructing function
function DCAP(nR::Int, nN::Int, nT::Int, nS::Int, seed::Int=1)::JuMP.Model

	# generate instance data
	data = DCAPData(nR, nN, nT, nS, seed)
	
	# copy for readability
	R, N, T, S = data.R, data.N, data.T, data.S
	a, b, c, c0, d, Pr = data.a, data.b, data.c, data.c0, data.d, data.Pr
	
	# construct JuMP.Model using StructuredModel() defined in StructJuMP package
	model = StructuredModel(num_scenarios = nS)	# the keyword argument: num_scenarios = nS
	
	## Set 1st stage components using JuMP syntax
	@variable(model, x[i=R,t=T] >= 0)
	@variable(model, u[i=R,t=T], Bin)
	@objective(model, Min, sum(a[i,t]*x[i,t] + b[i,t]*u[i,t] for i in R for t in T))
	@constraint(model, [i=R,t=T], x[i,t] - u[i,t] <= 0)
	
	## Set 2st stage components using StructJuMP syntax
	for s in S	# for all the scenarios
		# declare a StructuredModel `sb' (sibling) that must have three keyword arguments: parent=model (defined above), id=s, prob=Pr[s]
		sb = StructuredModel(parent=model, id=s, prob=Pr[s])	
		# declare 2nd stage variables. You must not put the scenario-specific index for the 2nd stage variables. They are internally distiguished by `id' (one of the keyword arguments of StructuredModel()).
		@variable(sb, y[i=R, j=N, t=T], Bin)
		@variable(sb, z[j=N,t=T] >= 0)
		# declare the recourse objective function using JuMP syntax. Again, you don't need to worry about taking expectation. But, be very careful about indices of the scenario data containers (i.e., c[i,j,t,s] and c0[j,t,s]). They need to be explicit since they are not members of StructuredModel.
		@objective(sb, Min, 
				sum(c[i,j,t,s]*y[i,j,t] for i in R for j in N for t in T) +
				sum(c0[j,t,s]*z[j,t] for j in N for t in T)
		)
		# declare the 2nd stage constrains using JuMP syntax. Again, be very careful about indices of the scenario data container (i.e., d[j,t,s])
		@constraint(sb, [i=R, t=T], 
				-sum(x[i,tau] for tau in 1:t) + sum(d[j,t,s]*y[i,j,t] for j in N) <= 0
		)
		@constraint(sb, [j=N, t=T], 
				sum(y[i,j,t] for i in R) + z[j,t] == 1
		)
	end
	
	return model
end

\end{lstlisting}
	
\subsection{Check if everything is well done}
Your directory \texttt{/dir/Siplib/src/problem/DCAP/} must contain the two \julia\ scripts.\\

\begin{forest}
	for tree={
		font=\ttfamily,
		grow'=0,
		child anchor=west,
		parent anchor=south,
		anchor=west,
		calign=first,
		inner xsep=7pt,
		edge path={
			\noexpand\path [draw, \forestoption{edge}]
			(!u.south west) +(7.5pt,0) |- (.child anchor) pic {folder} \forestoption{edge label};
		},
		% style for your file node 
		file/.style={edge path={\noexpand\path [draw, \forestoption{edge}]
				(!u.south west) +(7.5pt,0) |- (.child anchor) \forestoption{edge label};},
			inner xsep=2pt,font=\small\ttfamily
		},
		before typesetting nodes={
			if n=1
			{insert before={[,phantom]}}
			{}
		},
		fit=band,
		before computing xy={l=15pt},
	}  
	[Siplib
	[src
	[problems
	[DCAP
	[DCAP\_data.jl,file]
	[DCAP\_models.jl,file]
	]
	]
	[Siplib.jl,file]
	[smpswriter.jl,file]
	[generator.jl,file]
	[analyzer.jl,file]
	[utility.jl,file]
	]
	]
	]
\end{forest}

Then, try the following steps.
\begin{enumerate}
	\item Open a terminal and change working directory to \texttt{dir/Siplib/src/}:
\begin{lstlisting}[frame=single,language=julia]
user@LINUX:~$ cd dir/Siplib/src
\end{lstlisting}
	\item Run \julia\ in that directory. For example,
\begin{lstlisting}[frame=single,language=julia]
user@LINUX:~/dir/Siplib/src$ julia
\end{lstlisting}
	\item Excute \texttt{include("Siplib.jl")}
\begin{lstlisting}[frame=single,language=julia]
julia> include("Siplib.jl")
\end{lstlisting}
	\item Excute \texttt{using Siplib}
\begin{lstlisting}[frame=single,language=julia]
julia> using Siplib
\end{lstlisting}
	\item Execute the following line to generate DCAP\_2\_2\_2\_10 instance (don't forget to put colon in front of the problem name):
\begin{lstlisting}[frame=single,language=julia]
julia> generateSMPS(:DCAP, [2,2,2,10])
\end{lstlisting}
\end{enumerate}
	If it works well, you will see the three \smps\ files in \texttt{dir/Siplib/instance}:\\
	
\begin{forest}
	for tree={
		font=\ttfamily,
		grow'=0,
		child anchor=west,
		parent anchor=south,
		anchor=west,
		calign=first,
		inner xsep=7pt,
		edge path={
			\noexpand\path [draw, \forestoption{edge}]
			(!u.south west) +(7.5pt,0) |- (.child anchor) pic {folder} \forestoption{edge label};
		},
		% style for your file node 
		file/.style={edge path={\noexpand\path [draw, \forestoption{edge}]
				(!u.south west) +(7.5pt,0) |- (.child anchor) \forestoption{edge label};},
			inner xsep=2pt,font=\small\ttfamily
		},
		before typesetting nodes={
			if n=1
			{insert before={[,phantom]}}
			{}
		},
		fit=band,
		before computing xy={l=15pt},
	}  
	[Siplib
	[instance
	[DCAP\_2\_2\_2\_10.cor,file]
	[DCAP\_2\_2\_2\_10.tim,file]
	[DCAP\_2\_2\_2\_10.sto,file]
	]
	]
\end{forest}

\appendix
\section*{Appendix}
\section{\dcap: Dynamic capacity planning with stochastic demand} \label{DCAP}
\dcap\ is the problem of determining a capacity expansion schedule for a set of resources, and the assignment of resource capacity to task with stochastic requirement over a multi-period planning horizon.
%In \texttt{SIPLIB}, 12 instances are available in \texttt{SMPS} format with the largest instance comprises of 500 scenarios correspond to the size of 9,012 rows and 18,018 columns. 

%\dcap\ is a problem of deciding the capacity expansion schedule for $m$ resources over $T$ time periods in order to satisfy the processing requirements of $n$ tasks.
\subsection{\dcap: Mathematical formulation}
We consider the problem of deciding the capacity expansion schedule for $|R|$ resources over $|T|$ time periods to satisfy the processing requirements of $|N|$ tasks where $R$, $T$, and $N$ denote set of resources, set of time periods, and set of tasks, respectively. We define decision variables: the first-stage continuous variable $x_{it}$ for the capacity acquisition of resource $i$ in period $t$ and the second-stage binary variable $y_{ijt}^s$ to indicate whether resource $i$ is assigned to task $j$ in period $t$ under scenario $s$. Additional first-stage binary variable $u_{it}$ is for logical constraint whether or not we decided to acquire more capacity of resource $i$ in period $t$. Hence, for all resource $i\in R$ and time $t\in T$, $u_{it}=1$ if $x_{it}>0$, $u_{it}=0$ otherwise. 

Under the definition of the decision variables, the extensive form of \dcap\ is written below and the summarized notation is available in Table \ref{dcap:notation}.

\begin{subequations} \label{dcap:formulation}
	\begin{align}
	(\dcap)\ \textrm{min}\ &\sum_{t\in T}\sum_{i\in R}\left(\alpha_{it}x_{it}+\beta_{it}u_{it}\right)+\sum_{s\in\mathcal{S}}\PP(s)\sum_{t\in T}\sum_{i\in R\cup\{0\}}\sum_{j\in N}c_{ijt}^{s}y_{ijt}^s	\label{dcap:obj} \\
	\textrm{s.t.}\ & x_{it}\le \textrm{M}u_{it},\quad\forall i\in R,\ \forall t\in T,	\label{dcap:b}\\
	&\sum_{j\in N}d_{jt}^s y_{ijt}^s\le\sum_{\tau=1}^{t}x_{i\tau},\quad\forall i\in R,\ \forall t\in T,\ \forall s\in\mathcal{S},\label{dcap:c}\\
	&\sum_{i\in R\cup \{0\}}y_{ijt}^s=1,\quad\forall j\in N,\ \forall t\in T,\ \forall s\in\mathcal{S}, \label{dcap:d} \\
	&x_{it}\ge 0,\quad\forall i\in R,\ \forall t\in T,\label{dcap:e} \\
	&u_{it}\in\{0,1\}, \quad\forall i\in R,\ \forall t\in T,\label{dcap:f}\\
	&y_{ijt}^s\in\{0,1\},\quad\forall i\in R\cup\{0\},\ \forall j\in N,\ \forall t\in T,\ \forall s\in\mathcal{S},\label{dcap:g}
	\end{align}
\end{subequations}
The objective function (\ref{dcap:obj}) is to minimize total expected cost for the capacity expansion schedule. The first double summation denotes the expansion cost for resource $i$ in period $t$ where $\alpha_{it}$ and $\beta_{it}$ are the variable and fixed cost, respectively. The second term in the objective function represents the expected assignment cost in period $t$ over all scenario $s\in\mathcal{S}$. Note that a dummy resource $i=0$ is included with infinite capacity. The cost $c_{0jt}^s$ denotes the penalty of failing to assign a resource to task $j$. The dummy resource enforces the \textit{complete recourse property}, which ensures that there is a feasible second-stage assignment in all periods and all scenarios for any capacity acquisition schedule. Constraint (\ref{dcap:b}) is the logical constraint containing a suitably large value M (we set M=1 in \siplibtwo\ to follow the original implementation in \siplib\, although it does not seem to be large enough) to define the cost for capacity expansion. Constraint (\ref{dcap:c}) reflects that the processing requirement of all tasks assigned to a resource in any period cannot exceed the installed capacity in that period under all scenarios. Constraint (\ref{dcap:d}) guarantees that each task needs to be assigned to exactly one resource in each period under all scenarios. Finally, constraints (\ref{dcap:e})-(\ref{dcap:g}) restrict the space from which the variables take values.

\begin{table}[H]
	\caption{Notations for \dcap}
	\label{dcap:notation}
	\resizebox{\textwidth}{!}
	{
		\begin{tabular}{ll}
			\toprule
			\multicolumn{2}{l}{\textbf{Index sets:}} \\
			$R$ & index set of resources ($i\in R\cup\{0\}$ where $0$ is a dummy resource with infinite capacity) \\ 
			$N$ & index set of tasks ($j\in N$)\\ 
			$T$ & index set of time periods ($t\in T$)\\
			$\mathcal{S}$ & index set of scenarios ($s\in \mathcal{S}$) \\ \midrule
			\multicolumn{2}{l}{\textbf{Parameters:}} \\
			$\alpha_{it}$ & variable cost for expanding capacity of resource $i$\\ 
			$\beta_{it}$ & fixed cost for expanding capacity of resource $i$ \\ 
			$c_{ijt}^{s}$ & cost of processing task $j$ using resource $i$ in period $t$ under scenario $s$ \\ 
			$d_{jt}^s$	& processing requirement for task $j$ in period $t$ under scenario $s$		\\
			$\PP(s)$ & \textrm{the probability of occurence of scenario $s$} \\ \midrule
			\multicolumn{2}{l}{\textbf{Decision variables:}} \\
			$x_{it}$ (1st-stage) & capacity acquisition amount of resource $i$ in period $t$ \\ 
			$u_{it}$ (1st-stage)& 1 if capacity of resource $i$ is expanded in period $t$, 0 otherwise \\ 
			$y_{ijt}^s$ (2nd-stage)& 1 if resource $i$ is assigned to task $j$ in period $t$ under scenario $s$, 0 otherwise\\
			\bottomrule
		\end{tabular}
	}
\end{table} 

\subsection{\dcap: Data generation} \label{subsubsec:dcap_data_gen}
There are four factors that define the instance of \dcap: $|R|$, $|N|$, $|T|$, and $|\mathcal{S}|$. Once we decide the factors, the instance is named by DCAP\_$|R|$\_$|N|$\_$|T|$\_$|\mathcal{S}|$. Let $U$ be a continuous uniform random variable: $U\sim Unif(0,1)$. Then, the parameters are generated as follows:
\begin{align*}
\alpha_{it}&=5U+5,\quad\forall i\in R,\ \forall t\in T, \\
\beta_{it} &=40U+10,\quad\forall i\in R,\ \forall t\in T, \\
c_{ijt}^s  &=5U+5,\quad\forall i\in R,\ \forall j\in N,\ \forall t\in T,\ \forall s\in\mathcal{S}, \\
c_{0jt}^s  &=500U+500,\quad\forall j\in N,\ \forall t\in T,\ \forall s\in\mathcal{S}, \\
d_{jt}^s   &=U+0.5,\quad\forall j\in N,\ \forall t\in T,\ \forall s\in\mathcal{S}.
\end{align*}

\end{document}
