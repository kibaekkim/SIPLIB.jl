\siplibtwo\ is implemented in \texttt{Julia} programming language with algebraic modeling packages \texttt{JuMP} and \texttt{StructJuMP}. We implement and provide \texttt{Julia} package \texttt{Siplib.jl} for users to utilize ingredients of \siplibtwo. In this section, we introduce how to use \texttt{Siplib.jl}.

To use \texttt{Siplib.jl}, we need to perform the following steps.
\begin{itemize}
	\item install \texttt{Julia} $\ge$ version 0.6.2
	\item install \texttt{Julia} packages: \texttt{Distributions.jl}, \texttt{JuMP.jl}, \texttt{StructJuMP.jl}, \texttt{PyPlot.jl}
	\item change working directory to ``\texttt{$\sim$/Siplib/src/}''
	\item run \texttt{Julia}
	\item excute \texttt{include("Siplib.jl")}
	\item excute \texttt{using Siplib}
\end{itemize}

\begin{lstlisting}[frame=single,language=julia]

\end{lstlisting}

\begin{lstlisting}[frame=single,language=julia]
function getJuMPModel(problem::Symbol, param_arr::Any)::JuMP.Model

\end{lstlisting}

\subsection{Generating instances: \texttt{JuMP.Model}-object and \texttt{SMPS} files}
\texttt{JuMP.Model}-type object is an object that contains every information of an instance. Hence, almost every function in \texttt{Siplib.jl} requires \texttt{JuMP.Model}-type object as one of its input arguments. \texttt{Siplib.jl} provides two functions to construct the \texttt{JuMP.Model}-type object of an instance.
\begin{lstlisting}[frame=single,language=julia]
function getJuMPModel(problem::Symbol, param_arr::Any)::JuMP.Model
function generateSMPS(problem::Symbol, param_arr::Any, DIR_NAME::String="$(dirname(@__FILE__))/../instance")::JuMP.Model
\end{lstlisting}

The first function \texttt{getJuMPModel} takes \texttt{Symbol}-typed argument \texttt{problem} and associated parameter array \texttt{param\_arr}. Then, it constructs \texttt{JuMP.Model}-type object and return it. For example, the follwing command returns the \texttt{JuMP.Model} object of instance DCAP\_3\_4\_2\_100.
\begin{lstlisting}[frame=single,language=julia]
getJuMPModel(:DCAP, [3,4,2,100])
\end{lstlisting}
Keep in mind that the number of elements in \texttt{param\_arr} should match with the problem as in Table \ref{table:numparameter}, otherwise it prints a warning message.

\begin{table}[h]
	\centering
	\caption{\texttt{problem} arguments and corresponding parameter array}
	\label{table:numparameter}
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{@{}ccc@{}}
			\toprule
			\texttt{problem}  & \texttt{param\_arr}     & Remark                                                                                                                                     \\ \midrule
			\texttt{:DCAP}               & \texttt{[R, T, N, $\mathcal{S}$]} & All parameters are integer.                                                                                                                \\
			\texttt{:MPTSPs}             & \texttt{[D, N, $\mathcal{S}$]}    & $D\in \{\mathrm{``D0"}, \mathrm{``D1"}, \mathrm{``D2"}, \mathrm{``D3"}\}$                                                              \\
			\texttt{:SIZES}              & \texttt{[$\mathcal{S}$]}          & All parameters are integer.                                                                                                                \\
			\texttt{:SMKP}               & \texttt{[I, $\mathcal{S}$]}       & All parameters are integer.                                                                                                                \\
			\texttt{:SSLP}               & \texttt{[I, J, $\mathcal{S}$]}    & All parameters are integer.                                                                                                                \\
			\texttt{:SUC}                & \texttt{[D, $\mathcal{S}$]}       & \multicolumn{1}{l}{$D\in \{\mathrm{``FallWD"}, \mathrm{``FallWE"}, \mathrm{``WinterWD"}, \mathrm{``WinterWE"}, $}                                             \\
			\multicolumn{1}{l}{}         & \multicolumn{1}{l}{}            & \multicolumn{1}{r}{$\mathrm{``SpringWD"}, \mathrm{``SpringWE"}, \mathrm{``SummerWD"}, \mathrm{``SummerWE"} \}$} \\ \bottomrule
		\end{tabular}
	}
\end{table}

The second function \texttt{generateSMPS} generates \texttt{SMPS} files as well as returns \texttt{JuMP.Model} object by taking one more argument \texttt{DIR\_NAME} to indicate a directory where the files are stored. The \texttt{SMPS} files are stored in the default folder ``\texttt{$\sim$/Siplib/instance/}'' unless the argument \texttt{DIR\_NAME} is specified. The file name is automatically generated using the arguments, e.g., \texttt{generateSMPS(:DCAP, [3, 4, 2, 100])} generates three files.
\begin{itemize}
	\item DCAP\_3\_4\_2\_100.cor
	\item DCAP\_3\_4\_2\_100.tim
	\item DCAP\_3\_4\_2\_100.sto
\end{itemize}
Sometimes one might want to generate \texttt{SMPS} files using pre-declared \texttt{JuMP.Model} object. The function \texttt{writeSMPS} is defined to do such task.
\begin{lstlisting}[frame=single,language=julia]
function writeSMPS(model::JuMP.Model, INSTANCE::String="instance", DIR_NAME::String="$(dirname(@__FILE__))/../instance")
\end{lstlisting}
The function above takes \texttt{JuMP.Model} object as input argument and stores \texttt{SMPS} files into \texttt{DIR\_NAME} folder with file name \texttt{INSTANCE}. \texttt{INSTANCE} and \texttt{DIR\_NAME} can be omitted since they have default values ``\texttt{instance}" and ``\texttt{$\sim$/Siplib/instance/}."
\subsection{Pre-analyzing instances: size, sparsity, plot}

\subsubsection{Size information}

\subsubsection{Sparsity information}

\subsubsection{Plotting coefficient matrices}

\subsection{Solving instances: interfacing with \texttt{DSP} solver}
\subsubsection{Extensive form: Invoking standard MIP solver}

\subsubsection{Dual decomposition}

\subsubsection{Benders decomposition}