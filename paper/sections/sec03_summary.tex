In this section, we explain information about the test problems in summarized manner. This includes problem origin, type, components (variables and constraints), and sparsity for each problem. This section also contains the philosophy in implementation of \siplibtwo. Detailed problem-specific information is available in Section \ref{sec:prob_desc} for those who are interested in.

\subsection{Origin of the problems}
Table \ref{table:problems} summarizes the description of each test problem in \siplibtwo. The five of them are adopted from \siplib\ \cite{web:SIPLIB1}. We tried to implement the \siplib\ instances as the same as the original references possible. Not all of them, however, are exactly the same due to insufficient information on problem parameters, e.g., random numbers in scenarios. We guess the missing links and develop our own way to implement the problems as long as it does not harm the endemic problem-specific characteristic. 
\input{tables/table_siplib2_problems}

Table \ref{table:naming_rule} shows how we name the instances. We change the original naming rule for consistency and future extension. Some legacy naming rules do not consider the case when the set cardinality becomes larger than 1 digit numbers. Moreover, since some \siplibtwo\ instances can be generated using more sets other than used in \siplib, we needed to define a new naming convention. For example, we change the instances of \texttt{DCAP} and \texttt{SMKP} as below.
\begin{quote}
	\centering dcap$RNT$\_$\mathcal{S}$ $\longrightarrow$ DCAP$\_R\_N\_T\_\mathcal{S}$\\
	smkp$\_\mathcal{S}$ $\longrightarrow$ SMKP$\_I\_\mathcal{S}$
\end{quote}
The capital Roman letters mean the sets defining the problems and the calligraphic letter $\mathcal{S}$ means the scenario set. For notational convenience, we sometimes skip the cardinality sign $|\cdot|$ for sets, i.e., for set $S$, $S$ itself denotes the number of elements $|S|$ in Table \ref{table:naming_rule} and \ref{table:num_components}. Note that not all sets are used to define an instance. The sets that do not appear in the instance name are fixed by some pre-determined value by the original references so we follow them. For example, in \texttt{SMKP} there are 4 sets in total, $I,J,K,\mathcal{S}$, but the numbers of knapsacks $|J|$ and $|K|$ are fixed by 50 and 5.
\input{tables/table_instance_naming_rule}

\subsection{Type of the problems}
In \siplibtwo\, we mainly classify each problem by its stage-wise variable types. We consider three types of variable: continuous, binary, and integer. Considering two stages, the possible number of combination is $\left[\sum_{k=1}^3\binom{3}{k}\right]^2=49$ in total. We try to include problems with non-overlapping such combination. Table \ref{table:prob_class} shows the stage-wise components (variable and constraints) of each problem. For the abbreviated notation on the constraints, we refer \texttt{MIPLIB 2010} \cite{MIPLIB}. Although the constraint type is possibly one of the important factors that define the problem characteristic, we decided not to consider it for classification and let this future work since it can cause too much varieties, which we cannot easily capture the insight from the problem type classification. 
\input{tables/table_components_of_problems}

Table \ref{table:num_components} summarizes the number of components (variables and constraints) in each problem from \siplibtwo. The numbers can be calculated based on the cardinality of the sets that define the problems. Although there is no universally effective way to measure the difficulty of MILP yet, the number of components in instance is one of the closely related factor. For example, instances tend to be more difficult as the number of discrete variables increases. For those who want to generate instances with some desired number of components can utilize Table \ref{table:num_components}.
\input{tables/table_number_of_components}


\subsection{Sparsity in SIP}
In section \ref{sec:sparsity}, we provide block-wise sparsity which is fully based on the set cardinality. Every SIP has a block-diagonal structure in its coefficient matrix of the extensive form (Fig \ref{fig:de_structure}). This characteristic differentiates SIP from the general MIP where the sparsity pattern varies instance by instance. In particular,the block-diagonal structure results always in very high sparsity (i.e., low density of nonzeros) as scenario increases. It does not seem to be meaningful to just provide the sparsity information of the whole coefficient matrix since various decomposition-based algorithms in SIP can efficiently handle the sparsity. 

\input{figures/figure_sparsity_pattern}

As can be seen in Fig \ref{fig:stagewise_sparsity}, there are three different blocks in terms of the structure in it. Every other block is the duplication of block T or W hence the same sparsity pattern repeats as many as the number of scenarios considered. Block A and W are only related with their own stage while block T is related with both. We call the block T \textit{complicating} block. 

Dense coefficient matrix usually causes slowdown in decomposition algorithms. For example, the Dual Decomposition based solver \texttt{DSP} shows much slower convergence speed than the centralized solver \texttt{CPLEX} in problems like \texttt{SMKP} which always have low sparsity (50\%-100\%, Table \ref{table:sparsity_SMKP}).
\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{drawings/stagewise_sparsity}
	\caption{Three (structurally) independent blocks in SIP}
	\label{fig:stagewise_sparsity}
\end{figure}









