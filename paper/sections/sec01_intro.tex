%(What SIP is and our restriction) 
Stochastic (mixed) integer programming (SIP) is the mathematical programming that accounts for 
both continuous and discrete decision variables with uncertain parameters~\cite{book:BL2011}. 
Modeling and algorithms for SIP have been advanced for the last few decades. Applications of SIP include but not limited to power systems \cite{journal:PO2013,journal:KYZC2017}, telecommunications \cite{journal:SDC1994}, manufacturing systems \cite{journal:SPR1994,journal:AG2004}, and transportations \cite{journal:MW1969,journal:PGM2017,journal:TPP2017,journal:MPT2014}. With the advances, a number of solution methods have been developed and shown to be computationally effective for stochastic problems. Moreover, many of the algorithms have been implemented as software packages either specific for certain problems or for generic problems \cite{SCIP,journal:WWH2012,journal:KZ2015}.

In this paper, we focus on two-stage SIP throughout this research study. Note, however, that multi-stage SIP can be reformulated to a two-stage counterpart. Two-stage SIP is a representative uncertainty modeling framework which comprises linear objective function and constraints, where the first-stage decision finds a solution before the 
random parameters are realized, and the second-stage decision takes a recourse action to the uncertainty realization for a given first-stage decision. We assume that the random realization of problem parameters are discrete and finite with known probabilities.
A key challenge in SIP is that the size of
the problem increases with the number of scenarios. In particular, the number of integer variables increases in the number of scenarios. Moreover, the problem is nonconvex in variables. A number of solution techniques have been developed in order to address the challenges.

Numerical tests and benchmarks are necessary for developing and improving algorithms. However,
these have been challenging for the stochastic programming community, because of the limited number of test problem instances. To the best of our knowledge, only a few test libraries are available for stochastic programming. A portable stochastic programming test set (POSTS) \cite{POSTS} is a set of fifteen problem instances for 
stochastic linear programming in \smps\ format\footnote{\url{http://users.iems.northwestern.edu/~jrbirge/html/dholmes/post.html}}. Ariyawansa and Felt \cite{journal:AF2004} also provide nine problem instances for stochastic programming, including four SIP instances\footnote{\url{https://www4.uwsp.edu/math/afelt/slptestset/download.html}}. However, these libraries are not dedicated to SIP. 

Shabbir Ahmed has collected a set of nine SIP problem instances in his personal website\footnote{\url{https://www2.isye.gatech.edu/~sahmed/siplib/}}, called \siplib: A Stochastic Integer Programming Test Problem Library. The problem instances are provided in SMPS format \cite{smps} with additional information such as instance size, best known objective value or bounds, optimality gap, and solution time. \siplib\ has the following limitations. 
First, it provides instances with only a few variations of the first- and second-stage variables and a fixed number of scenarios, which can be easily parameterized in 
modeling languages. Moreover, the precise parameter information for the problem instances is 
not easily accessible. Second, the number of problem types is limited in 
the existing collection. Note that, with three variable types (i.e., continuous, 
binary, integer) for each of the two stages, the possible number of combinations for problem type is $\left[\sum_{k=1}
^3\binom{3}{k}\right]^2=49$ in total \kk{Not true, we do not consider binary-integer programs.}. 
The existing instances in \siplib\ covers only five of the combinations 
regarding the problems that can be fully implementable based on the open information. \kk{Please rewrite this. Not clear what you try to say.}
Third, it needs to provide more information such as pre-analysis on the 
instances and post-analysis on the benchmark results. Currently, there is no predefined 
contribution rule for \siplib\ so different problem provides different information. 
Therefore, interpretation on the new results can be incompatible with the former results. \kk{I cannot understand the last three sentences.}


%
%%\subsection{Literature review} \label{subsec:literaturereview}
%Meanwhile, the optimizers, not only SIP researchers, have always needed test instances to 
%figure out the performances of newly developed methods. \miplib\ \cite{MIPLIB} for mixed 
%integer (linear) programming (MIP) is a good example of such collection, which comprises 361 
%instances. The authors collected the instances from various sources and categorized them into 
%several groups after the computational experiments. \miplib\ provides instances in 
%\textsf{MPS} format with a test engine developed to run different solvers in a defined way to 
%check the answers for consistency. 
%
%
%%(Motivation) 
%At the time \siplib\ appeared, it provided enoughly large-sized instances that is reasonable 
%to argue that the performance of algorithm is remarkable if it handles the instances well. 
%State-of-the-art in SIP combined with the speedup in computing machinery, however, makes many 
%instances in \siplib\ trivial so that we have not enough basis to use them for showing the 
%excellence of newly suggested solution methods. At this point, we are motivated to develop 
%the second version of \siplib\, say \siplibtwo\ that provides larger-sized test instances 
%with higher degree of tailorability, e.g., users can easily generate instances of test 
%problems as largely as they want.% in terms of the number of scenarios included.
%
%At the time \siplib\ appeared, it provided enough instances to be used for computational 
%experiments of SIP methods. State-of-the-art in SIP combined with the speedup in computing 
%machinery, however, requires more test sets as the existing instances have been conquered 
%gradually. As \siplib\ only provides limited testing resources (e.g., static instance files), 
%it has less expandability. 
%Based upon the current limitations of \siplib, we conclude that the current \siplib\ needs to 
%be improved since state-of-the-art in SIP combined with the speedup in computing machinery 
%requires more test sets. At this point, we are motivated to develop the second version of 
%\siplib, say \siplibtwo, that includes richer testing resources. By ``richer", we mean the 
%three things. First, instances of the different type of problems other than existing ones. 
%Second, the larger-sized instances of the existing \siplib\ problems. Third, higher degree of 
%freedom for the researchers, e.g., users can easily generate instances of the size/shape as 
%they want.

%(SMPS, Julia)
In this work, we introduce \siplibtwo\, the second version of \siplib, in \smps\ file formats \cite{smps} as well as the algebraic models written in {\julia}. \smps\ is an extension of \mps\, a standard format widely used to describe a class of optimization problems, for stochastic programming. The \smps\ format consists of three files: a core file, a time file, and a stochastic file. \kk{SMPS is one of the main outcomes. We need to explain this for more details.} \smps\ format has been well accepted to the stochastic programming community and supported by existing software packages (e.g., {\dsp}~\cite{web:DSP}, \textsf{SMI}~\cite{web:SMI}, {\scip}~\cite{SCIP}). However, a key drawback of \smps\ is the lack of flexibility for reading and modifying the existing instances. 

To overcome the drawback of solely providing the test instances in \smps\ format, we also develop a \julia\ package that writes algebraic SIP models in \smps\ files. Specifically, the \julia\ package is capable of creating and modifying SIP problem instances and writing them in \smps\ files. This will allow users to obtain new \smps\ files of different instances (e.g., increased number of scenarios). The package also provides various functionalities for numerical study and analysis. For example, the package can query instance size, sparsity pattern, and some known lower/upper bounds. \kk{Note that the modeling is not really our capability, but from StructJuMP (need to cite and acknowledge the work). Hence, we may focus more on the flexibility that was not possible with SMPS only.}
%%(Convenience of Julia) 
%\julia\ is an open-source high-level, high-performance dynamic programming language for 
%numerical computing. It is also known as good performance, approaching that of statically
%compiled languages like \clang\ \cite{journal:BEKS2017}. The syntax of \julia\ is simple and 
%should feel familiar to anyone who has experienced in another high-level languages like 
%\matlab\ or \python. A \julia\ package called \jump\ (\julia\ for Mathematical Programming 
%\cite{journal:JuMP}) provides a domain-specific modeling language for mathematical 
%optimization embedded in \julia. \jump\ enables us to easily translate a paper-written 
%mathematical models to a \jumpmodel-type object. Some structured mathematical models 
%like SIP can also be translated to the \jumpmodel-type object by loading a 
%structured modeling package \structjump\ \cite{web:StructJuMP}. Once we have a \julia\ script 
%for constructing \texttt{JuMP.Model}-type object, it is easy to modify the original model. 

%(Contribution of SIPLIP2.0) 
The contributions of this work are summarized as follows.
\begin{itemize}
	\item We develop \siplibtwo\ with a set of new SIP problem instances, in addition to the instances in \siplib.
	\item We provide the SIP problem instances in \julia\, as well as SMPS format, which enables to modify the instance-specific parameters (e.g., number of scenarios).
	\item We develop an open-source \julia\ package that implements a set of SIP instances in \julia\ with the capabilities of writing the \julia\ models in SMPS format and numerical analysis.
	\item We report the benchmark results for the problem instances by using the existing software packages.
\end{itemize}

%By \siplibtwo, we provide 1) richer collection of test instances for computational 
%and algorithmic research in SIP with benchmarking computational results, 2) not only 
%\smps\ files but also utilities for generating/analyzing instances. Hence, the users 
%can obtain as large-sized instances as they need by generating new scenarios and including 
%them into instances. For those who want to utilize the instances in the legacy 
%\siplib\ with strong tailorability provided by \siplibtwo, we include the 
%original \siplib\ instances as well.

%(Contents)
This paper is organized as follows. In Section \ref{sec:sip}, we briefly review SIP. This 
includes the mathematical formulations, solution methods, and existing software 
packages. In Section \ref{sec:summary}, we describe the test 
problems. This describe the source for each problem, instance naming 
rule, problem type, number of components, and sparsity information. Section \ref{sec:package} presents the \julia\ package that implements the problem instances and other functions for numerical analysis. In Section \ref{sec:instance_catalog}, we report analytical and 
benchmark results of the \smps\ instances. We conclude this study with the 
emphasis on our spirit for further advances in SIP in Section \ref{sec:conclusion}. \kk{Needs to revisit.}







