%(What SIP is and our restriction) 
Stochastic (mixed) integer programming (SIP) is the mathematical programming that accounts for 
both continuous and discrete decision variables with uncertain parameters~\cite{book:BL2011}. 
Modeling and algorithms for SIP have been advanced for the last few decades. Applications of SIP include power systems~\cite{?}, healthcare~\cite{?}, manufacturing systems~\cite{?}, and transportation~\cite{?}. With the advances, a number of solution methods have been developed and shown to be computationally effective for stochastic problems (e.g.,~\cite{?}). Moreover, many of the algorithms have been implemented as software packages either specific for certain problems~\cite{?} or for generic problems~\cite{?}.

Numerical tests and benchmarks are necessary for developing and improving algorithms. However,
these have been challenging for the stochastic programming community, because of the limited number of test problem instances. SIPLIB is a set of test problem instances for SIP available in~\url{https://www2.isye.gatech.edu/~sahmed/siplib/}, where nine problem instances are available in SMPS format~\cite{?} with additional information such as random parameters, 
instance size, best known objective value or bounds, optimality gap, and solution time.  

In this paper, we focus on two-stage SIP with 
linear objective function and constraints, where the first stage finds a solution before the 
random parameters are realized, and the second stage takes a recourse action to the 
uncertainty realization for a given first-stage decision. We assume that the random realization of problem parameters (i.e., scenarios) are discrete and finite with known probabilities.
A key challenge in SIP is that the size of
the problem increases with the number of scenarios. The main difficulty in solving two-stage SIP is that the 
second-stage value function is not necessarily convex. Thus, the standard decomposition 
approaches that work nicely for stochastic \textit{linear} programs, break down when the 
second stage integer variables are present \cite{journal:AG2004}. Hereinafter, we use the 
term SIP to indicate the two-stage SIP. 


%\subsection{Literature review} \label{subsec:literaturereview}
Meanwhile, the optimizers, not only SIP researchers, have always needed test instances to 
figure out the performances of newly developed methods. \miplib\ \cite{MIPLIB} for mixed 
integer (linear) programming (MIP) is a good example of such collection, which comprises 361 
instances. The authors collected the instances from various sources and categorized them into 
several groups after the computational experiments. \miplib\ provides instances in 
\textsf{MPS} format with a test engine developed to run different solvers in a defined way to 
check the answers for consistency. 

%(website: Derek Holmes, POSTS, 1993)
For SP, to the best of our knowledge, the first such approach is Holmes and Birge's 
\textit{portable stochastic programming test set} (POSTS) \cite{POSTS} since 1994. POSTS is 
still available and provides a small test set of stochastic programming recourse problems in 
\smps\ format. POSTS consists of 15 problems but not dedicated to SIP. Birge 
\cite{POSTSresults} provides some computational results of the POSTS instances, but most of 
them needs to be updated. Moreover, accompanied information on the instances does not seem to 
be enough. 

%(website and paper: Andy Felt, Jason Sarich, and K. A. Ariyawansa, Test-Problem Collection 
%for Stochastic Linear Programming, 2001-2004)
Ariyawansa and Felt \cite{journal:AF2004} have constructed a test problem collection for SP 
since 2001. Unlike Holmes and Birge's work, the authors provide an accompanied document 
explaining short description, mathematical problem statement, and notational reconciliation 
to a standard problem format for each of the 9 problems. Ariyawansa and Felt's collection 
includes 3 problems that contain mixed integer variables. However, still the library is not 
dedicated to SIP and size of the instances are not large enough to perform intensive 
computational experiments. 

%(website: SIPLIB 1)
The first SIP-oriented instance collection is the \siplib\ \cite{web:SIPLIB1} constructed in 
2002 by Shabbir Ahmed and his colleagues. The instances are basically given in \smps\ format 
accompanied with simple information on the problem and computational experiment. Although 
\siplib\ provides basic ingredient to be exploited for SIP research, it has rooms for 
improvement. First, \siplib\ only provides static instances and sometimes does not even 
provide ready-to-use instance files, which limits usability of the library. Moreover, the 
precise information for implementing the original problem is sometimes not allowed. Second, 
we need more problems of various types. Considering three types of variables (continuous, 
binary, integer) and two stages, the possible number of combination is $\left[\sum_{k=1}
^3\binom{3}{k}\right]^2=49$ in total while \siplib\ provides only 5 such combinations 
regarding the problems that can be fully implementable based on the open information.
Third, \siplib\ needs to be polished systematically in terms of both pre-analysis on the 
instances and post-analysis on the benchmark results. Currently, there is no predefined 
contribution rule for \siplib\ so different problem provides different information. 
Therefore, interpretation on the new results can be inconsistent.

%(Motivation) 
%At the time \siplib\ appeared, it provided enoughly large-sized instances that is reasonable 
to argue that the performance of algorithm is remarkable if it handles the instances well. 
State-of-the-art in SIP combined with the speedup in computing machinery, however, makes many 
instances in \siplib\ trivial so that we have not enough basis to use them for showing the 
excellence of newly suggested solution methods. At this point, we are motivated to develop 
the second version of \siplib\, say \siplibtwo\ that provides larger-sized test instances 
with higher degree of tailorability, e.g., users can easily generate instances of test 
problems as largely as they want.% in terms of the number of scenarios included.

%At the time \siplib\ appeared, it provided enough instances to be used for computational 
experiments of SIP methods. State-of-the-art in SIP combined with the speedup in computing 
machinery, however, requires more test sets as the existing instances have been conquered 
gradually. As \siplib\ only provides limited testing resources (e.g., static instance files), 
it has less expandability. 
Based upon the current limitations of \siplib, we conclude that the current \siplib\ needs to 
be improved since state-of-the-art in SIP combined with the speedup in computing machinery 
requires more test sets. At this point, we are motivated to develop the second version of 
\siplib, say \siplibtwo, that includes richer testing resources. By ``richer", we mean the 
three things. First, instances of the different type of problems other than existing ones. 
Second, the larger-sized instances of the existing \siplib\ problems. Third, higher degree of 
freedom for the researchers, e.g., users can easily generate instances of the size/shape as 
they want.

%(SMPS, Julia)
We provide \siplibtwo\ in two ways: \smps\ files (*.cor, *.tim, *.sto) and open-source 
\julia\ package. \smps\ is a file format widely used to describe stochastic program 
instances. Once \smps\ files are given, we can directly solve it using SIP solvers like \dsp\ 
\cite{web:DSP} and \textsf{SMI} \cite{web:SMI}. A drawback of \smps\ is low 
readability by human, which we decided to provide \julia\ scripts to let users be able to 
easily catch up the problems and tailor the instances if needed.

%(Convenience of Julia) 
\julia\ is an open-source high-level, high-performance dynamic programming language for 
numerical computing. It is also known as good performance, approaching that of statically-
compiled languages like \clang\ \cite{journal:BEKS2017}. The syntax of \julia\ is simple and 
should feel familiar to anyone who has experienced in another high-level languages like 
\matlab\ or \python. A \julia\ package called \jump\ (\julia\ for Mathematical Programming 
\cite{journal:JuMP}) provides a domain-specific modeling language for mathematical 
optimization embedded in \julia. \jump\ enables us to easily translate a paper-written 
mathematical models to a \texttt{JuMP.Model}-type object. Some structured mathematical models 
like SIP can also be translated to the \texttt{JuMP.Model}-type object by loading a 
structured modeling package \structjump\ \cite{web:StructJuMP}. Once we have a \julia\ script 
for constructing \texttt{JuMP.Model}-type object, it is easy to modify the original model. 
%For each problem in \siplibtwo, we provide a \julia\ script for constructing 
\texttt{JuMP.Model}-type object. 

Using SP-related packages, we implement a new \julia\ package to provide various 
functionalities for handling \siplibtwo\ instances for users' convenience. Those who feel the 
given instances are not enough can simply generate new instances using the package.


%(Contribution of SIPLIP2.0) 
The contributions of this work can be summarized as follows.
\begin{itemize}
	\item We provide SIP-dedicated testing resources that are richer than the former \siplib.
	\item We collect, implement, summarize, and open all the problem-specific details: 
	mathematical formulation, stochastic data generation, \julia\ scripts.
	\item We implement and release an open-source \julia\ package for SIP research: 
	generating and analyzing the instances.
	\item We provide both analytical and computational information on the accompanied 
	instances.
\end{itemize}

%By \texttt{SIPLIB 2.0}, we provide 1) richer collection of test instances for computational 
and algorithmic research in SIP with benchmarking computational results, 2) not only 
\texttt{SMPS} files but also utilities for generating/analyzing instances. Hence, the users 
can obtain as large-sized instances as they need by generating new scenarios and including 
them into instances. For those who want to utilize the instances in the legacy 
\texttt{SIPLIB} with strong tailorability provided by \texttt{SIPLIB 2.0}, we include the 
original \texttt{SIPLIB} instances as well.

%(Contents)
This paper is organized as follows. In Section \ref{sec:sip}, we briefly review SIP. This 
includes the mathematical formulation with notation, solution methods, and available software 
packages. In Section \ref{sec:summary}, we provide summary and discussion of the test 
problems. This consists of origin of the problems with brief description, instance naming 
rule, problem type, the number of components, and sparsity information. We also discuss why 
they are important in each subsection. Together with the problem-specific description given 
in Section\ref{sec:prob_desc}, we believe that users can quickly catch up what they need 
without investigating every detail. In Section \ref{sec:package}, we introduce our 
implementation of a \julia\ package for \siplibtwo\ with a tutorial in Section 
\ref{sec:tutorial}. In Section \ref{sec:instance_catalog}, we report analytical and 
computational results of the accompanied \smps\ instances. We conclude this study with the 
emphasis on our spirit for further improvement in SIP in Section \ref{sec:conclusion}. 







