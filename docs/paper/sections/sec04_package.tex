%\yoc{The contents of this section are completely changed. I tried to describe the structure and functionalities of the package rather than step-by-step tutorials. Users may refer to this section to participate in future improvement.}
We implement and release an open-source software package that provides diverse functionalities dedicated to computational research study for SIP with main emphasis on generating \smps\ format instances. The package is implemented in \julia\ programming language with algebraic modeling package \jump\ with its structural extension \structjump. Detailed tutorial about how to use the package is available in Section \ref{sec:tutorial}. 

We believe that the \siplibtwo\ package is easy to use so the users can utilize the basic functions without much familiarity with \julia\ syntax. Moreover, the package is designed for being improved consistently in the future. For example, we expect more SIP problems and useful functionalities to be added by researchers in this field on top of the current initial release.
%\kk{An overall comment is that the minimal use of code syntax is usually good. Once the paper is published, the syntax is likely to change overtime. Then, the whole section will become wrong. For example, instead of using Siplib.jl, we can call the package or function.}
%\yoc{Thanks. First of all, this section is written by benchmarking the MIPLIB 2010 paper. There is a section like this (Section 4: How to run a test, add a solver, and what the scripts do) so I think the reviewers of MPC may want us to include the section like this. And I wanted this draft to be look of completeness (not being looked abstractly) to concretely describe what is in my mind. As the main developer of SIPLIB 2.0 and based on my experience of using the Julia scripts for preliminary computational experiments, I think the current syntax I propose is reasonable and compact. The better suggestion/discussion on the syntax is always welcome and can be applied. More detailed manual will be surely accompanied later with the release of this package.} 
%\kk{We may have a better idea about this section, once you start answering the questions at the end of Section 4.2. But, for now I still think it would better simply cite a github page for this kind of information.}
\subsection{Preliminaries}
\subsubsection{\smps\ format} \label{subsec:smps}
\smps\ format is a data convention for the automatic input of multi-stage stochastic programs \cite{smps}. The format is designed to extend \mps\ format, a column-oriented standard for deterministic program, to stochastic program by introducing periodicity and scenario variants in separate files. The following three input files are required to specify a stochastic program instance in \smps\ format:
\begin{itemize}
	\item .cor: Core file written in \mps\ format. This describes the fundamental problem structure and contains the first-stage data and a single second-stage scenario data.
	\item .tim: Time file which specifies the location where each stage begins.
	\item .sto: Stoch file which contains scenario data.
\end{itemize}
The most important functionality of the \siplibtwo\ package is to generate \smps\ files given an instance that can be also generated by a function defined in the package. For example, the package generates the following three files for a \dcap\ instance \dcap\_$R$\_$N$\_$T$\_$S$ by executing \texttt{generateSMPS(:DCAP, [R,N,T,S])}.
\begin{itemize}
	\item DCAP\_R\_N\_T\_S.cor
	\item DCAP\_R\_N\_T\_S.tim
	\item DCAP\_R\_N\_T\_S.sto
\end{itemize}

\subsubsection{\jumpmodel}
\jumpmodel\ is a composite type (or struct, class, etc) defined in \jump\ package. Combining \structjump\ package together, constructing a \jumpmodel\ object of an SIP instance is straightforward and much simpler than any other algebraic modeling languages. For example, the script in Figure \ref{fig:DCAP_model.jl} constructs an object \texttt{model} for \dcap\_$R$\_$N$\_$T$\_$S$ instance defined in formulation (\ref{dcap:obj})-(\ref{dcap:g}). 

An object of this type contains every information of an instance. Hence, most functions defined in the package require this object as one of the input arguments. The package provides a function to construct \jumpmodel\ object, e.g., \texttt{model = getModel(:DCAP, [R,N,T,S])} constructs an object \texttt{model} for an instance \dcap\_$R$\_$N$\_$T$\_$S$.
%
%\subsection{Structure of the \julia\ package}
%The tree in Fig. \ref{fig:siplibjl_structure} shows how the \julia\ package is structured. 
%\begin{figure}[H] 
%	\centering   
%	\begin{forest}
%		for tree={
%			font=\ttfamily,
%			grow'=0,
%			child anchor=west,
%			parent anchor=south,
%			anchor=west,
%			calign=first,
%			inner xsep=7pt,
%			edge path={
%				\noexpand\path [draw, \forestoption{edge}]
%				(!u.south west) +(7.5pt,0) |- (.child anchor) pic {folder} \forestoption{edge label};
%			},
%			% style for your file node 
%			file/.style={edge path={\noexpand\path [draw, \forestoption{edge}]
%					(!u.south west) +(7.5pt,0) |- (.child anchor) \forestoption{edge label};},
%				inner xsep=2pt,font=\small\ttfamily
%			},
%			before typesetting nodes={
%				if n=1
%				{insert before={[,phantom]}}
%				{}
%			},
%			fit=band,
%			before computing xy={l=15pt},
%		}  
%		[Siplib
%		[src
%		[problems
%		[DCAP
%		[dcap\_types.jl,file]
%		[dcap\_functions.jl,file]
%		[dcap\_models.jl,file]
%		]
%		[MPTSPs]
%		[SIZES
%		[DATA
%		[oneperioddata.csv,file]
%		]
%		[sizes\_types.jl,file]
%		[sizes\_functions.jl,file]
%		[sizes\_models.jl,file]			
%		]
%		[SMKP]
%		[SSLP]
%		[SUC]
%		]
%		[Siplib.jl,file]
%		[smpswriter.jl,file]
%		[generator.jl,file]
%		[analyzer.jl,file]
%		[utility.jl,file]
%		]
%		]
%		]
%	\end{forest}
%	\caption{Structure of the \julia\ package}\label{fig:siplibjl_structure}
%\end{figure}
%
%\texttt{src} folder on the top contains every implementation of the package. In the directly descendant folder \texttt{problems}, another folders with names for each problem present. Some folders in \texttt{problems} (e.g., \texttt{SIZES}) have \texttt{DATA} folder in it which contains external data for generating the instances. For example, the \texttt{DATA} folder under \texttt{SIZES} contains \texttt{oneperioddata.csv} file corresponding to Table \ref{sizes:data} for \sizes\ instances. 
\subsection{How to add a new SIP problem into the package}
Adding a new problem to the package is as  simple as (i) adding a line to the existing .csv file and (ii) implementing one or two \julia\ scripts for the problem. One thing to keep in mind is that this procedure should follow the predefined way, e.g., folder name, script file name, composite-type name, function name, and arguments of the functions.\\

\noindent\textit{Step 1. Modification of \texttt{Siplib/src/problem\_info.csv}} The .csv file contains basic information of each problem: problem name, number of parameters, simple description for the parameters. Table \ref{table:problem_info.csv} shows the spread sheet representation of the .csv file. In order to add a new problem into the package, a new line for that problem should be appended at the bottom.
\begin{table}[H]
	\centering
	\caption{\texttt{problem\_info.csv} (spreadsheet representation)}
	\label{table:problem_info.csv}
	\begin{tabular}{|c|c|c|}
		\hline
		problem\_name & number\_of\_parameters & parameter\_description          \\ \hline
		DCAP          & 4                      & {[}R, N, T, S{]}, All integers. \\ \hline
		SMKP          & 2                      & {[}I, S{]}, All integers.       \\ \hline
		SSLP          & 3                      & {[}I, J, S{]}, All integers.    \\ \hline
		$\vdots$	&	$\vdots$	&	$\vdots$
		\\ \hline
	\end{tabular}
\end{table}

%\subsubsection{Implementation of modeling script \texttt{\_model.jl}}
\noindent\textit{Step 2. Implementation of a modeling script} The modeling function for a problem should be defined in \textit{model} script, e.g., \texttt{DCAP\_model.jl}. When an user wants to add a new problem, this script is the minimum required implementation. Sometimes the data generating part is separated from the model script by \textit{data} script when the data generation is complicated so that makes the modeling function too messy (e.g., \suc).
\begin{quote}
	\noindent\textit{model} (necessary) This kind of script contains a definition of the function that constructs a \jumpmodel-type object. This function calls \structjump\ package and uses the modeling syntax defined in the package. Figure \ref{fig:DCAP_model.jl} shows an example of \dcap: \texttt{DCAP\_model.jl}.
\end{quote}
\begin{quote}
	\noindent\textit{data} (optional) For some problems that have complicated data generation procedure, we implement this script separately from the \textit{model} script. This includes a definition of composite-type in which data is stored. A data generating function is also defined in this script. The function generates the data and returns it as an object of the composite-type we defined. Whenever this data script exists separately, it must be included in the model script. Figure \ref{fig:DCAP_data.jl} shows an example of \dcap: \texttt{DCAP\_data.jl}.
\end{quote}

%
%\begin{quote}
%\noindent\textit{types} This kind of script defines the \textit{composite type} (also known as structure or aggregate data type in various languages) that is used to store data for constructing \jumpmodel\ object. The object of this composite type will contain all set and parameter data that define an instance. For example, \texttt{dcap\_types.jl} in Fig. \ref{fig:dcap_types}, defines the composite type \texttt{DCAPData}.
%\end{quote}
%\begin{figure}[H]
%	\centering
%	\begin{lstlisting}[frame=single,language=julia]
%	mutable struct DCAPData
%		# Sets
%		R   # set of resources 
%		N   # set of tasks 
%		T   # set of time periods 
%		S   # set of scenarios 
%		
%		# Parameters
%		a   # a[i,t]: variable cost for expanding capacity of resource i at time t
%		b   # b[i,t]: fixed cost for expanding capacity of resource i at time t
%		c   # c[i,j,t,s]: cost of processing task j using resource i in period t under scenario s
%		c0  # c0[j,t,s]: penalty cost of failing to assign a resource to task j under scenario s
%		d   # d[j,t,s]: processing requirement for task j in period t under scenario s
%		Pr  # Pr[s]: probability of occurence of scenario s
%	
%		DCAPData() = new()
%	end
%	\end{lstlisting}
%	\caption{Example: \texttt{dcap\_types.jl}}\label{fig:dcap_types}
%\end{figure}


\begin{figure}[]
	\centering
	\begin{lstlisting}[frame=single,language=julia]
	function DCAP(nR::Int, nN::Int, nT::Int, nS::Int, seed::Int=1)::JuMP.Model
		
		# set random seed (default=1)
		srand(seed)
		
		# generate & store instance data
		## sets
		R = 1:nR
		N = 1:nN
		T = 1:nT
		S = 1:nS
		
		## parameters
		a = rand(nR, nT) * 5 + 5
		b = rand(nR, nT) * 40 + 10
		c = rand(nR, nN, nT, nS) * 5 + 5
		c0 = rand(nN, nT, nS) * 500 + 500
		d = rand(nN, nT, nS) + 0.5
		Pr = ones(nS)/nS
		
		# construct a structured JuMP.Model
		## declare an object
		model = StructuredModel(num_scenarios = nS)
		
		## declare 1st stage components
		@variable(model, x[i=R,t=T] >= 0)
		@variable(model, u[i=R,t=T], Bin)
		@objective(model, Min, sum(a[i,t]*x[i,t] + b[i,t]*u[i,t] for i in R for t in T))
		@constraint(model, [i=R,t=T], x[i,t] - u[i,t] <= 0)
		
		## declare 2nd stage components
		for s in S
			sb = StructuredModel(parent=model, id = s, prob = Pr[s])
			@variable(sb, y[i=R, j=N, t=T], Bin)
        	@variable(sb, z[j=N,t=T], Bin)
			@objective(sb, Min, sum(c[i,j,t,s]*y[i,j,t] for i in R for j in N for t in T) + sum(c0[j,t,s]*z[j,t] for j in N for t in T))
			@constraint(sb, [i=R, t=T], -sum(x[i,tau] for tau in 1:t) + sum(d[j,t,s]*y[i,j,t] for j in N) <= 0)
			@constraint(sb, [j=N, t=T], sum(y[i,j,t] for i in R) + z[j,t] == 1)
		end
		
		return model
	end

	\end{lstlisting}
	\caption{An example of modeling SIP using \structjump: \texttt{DCAP\_model.jl}}\label{fig:DCAP_model.jl}
\end{figure}

\begin{figure}[]
	\centering
	\begin{lstlisting}[frame=single,language=julia]
	# definition of a composite type
	mutable struct DCAPData	
		# Sets
		R   
		N  
		T   
		S  
		
		# Parameters
		a   
		b   
		c  
		c0  
		d   
		Pr  
		
		DCAPData() = new()	# constructor
	end
	
	# definition of a data generating function
	function DCAPData(nR::Int, nN::Int, nT::Int, nS::Int, seed::Int)::DCAPData

		srand(seed)
		data = DCAPData()
		
		# store Sets
		data.R = 1:nR	
		data.N = 1:nN	
		data.T = 1:nT	
		data.S = 1:nS	
		
		# generate and store Parameters
		data.a = rand(nR, nT) * 5 + 5
		data.b = rand(nR, nT) * 40 + 10	
		data.c = rand(nR, nN, nT, nS) * 5 + 5	
		data.c0 = rand(nN, nT, nS) * 500 + 500	
		data.d = rand(nN, nT, nS) + 0.5	
		data.Pr = ones(nS)/nS
		
		return data
	end
	\end{lstlisting}
	\caption{An example of generating data separately from a modeling function: \texttt{DCAP\_data.jl}}
	\label{fig:DCAP_data.jl}
\end{figure}

\subsection{Scripts for the supporting functionalities}
The \siplibtwo\ package implements various functions for investigating the factors we have discussed in Section \ref{sec:summary}. Each of the following scripts contains core components that comprise the functions.
\begin{quotation}
	\noindent\textit{generator} This script defines user-interfacing functions that directly generate \smps\ files of an instance and simultaneously returns corresponding \jumpmodel\ object.
\end{quotation}

\begin{quotation}
	\noindent\textit{writer} This script implements basic building blocks for the functions that convert \jumpmodel\ object to \smps\ files. 
\end{quotation}

\begin{quotation}
	\noindent\textit{analyzer} This script implements the functions for analysis of instances. This includes size information, sparsity information, and visual plots of sparsity pattern.
\end{quotation}

\begin{quotation}
	\noindent\textit{solver} This script implements the functions to solve an SIP instance constructed as a \jumpmodel\ object. The package provides four ways to solve an instance: \texttt{RP()}, \texttt{WS()}, \texttt{EEV()}, and \texttt{LP()}. The most basic function \texttt{RP()} solves the extensive form recourse problem whereas the others calculate the lower or upper bounds for the objective value of the recourse problem. Detailed definitions for them are found in Section \ref{subsec:sol_report}.
\end{quotation}

\begin{quotation}
	\noindent\textit{utility} This script contains some utility functions that help implementing the package. For example, instance naming, LP-relaxation, and matrix plotting, and so on.
\end{quotation}




